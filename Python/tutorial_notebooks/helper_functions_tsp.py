import numpy as np
import math
import copy

def read_file_name(locations, data_sources):
    """Find the filename for a certain number of locations
    
    Parameters
    ----------
    locations : int
        Number of locations, or vertices
    data_sources : dict
        Dictionary listing the filename for each problem siz

    Returns
    ----------
    filename : string
        The filename for that problem size
    """
    filename = data_sources[locations]['file']
    return(filename)       

def validate_distance_array(array, locs):
    """Validates the distance array and raises an Exception if the 
    array is not valid.  Checks the array is the correct shape, and
    is symmetric
    
    Parameters
    ----------
    array : array
        Numpy symmetric array with distances
    locs : int
        Number of locations or vertices

    """
    if len(np.shape(array)) !=2:
        raise Exception('The distance array is not two dimensional')
    for index in [0,1]:
        if np.shape(array)[index] != locs:
            raise Exception(f'The shape of the array does not match {locs} locations')
    #check symmetry
    for i in range(locs):
        for j in range(locs):
            if array[i,j] != array[j,i]:
                raise Exception('The array is not symmetrical')

def find_distance(loc1, loc2, distance_array,debug=False):
    """Finds the distance between locations using the distance matrix
    
    Parameters
    ----------
    loc1 : int
        First location
    loc2 : int
        Second location

    Returns
    ----------
    distance : Float
        The distance between two postal codes
    """
    
    distance = distance_array[loc1][loc2]
    if debug:
        print(f'The distance from location {loc1} to location {loc2} is {distance}')
    return(distance)

def find_bin_length(i):
    """find the length of a binary string to represent integer i"""
    bin_len = math.ceil((np.log2(i)))
    return(bin_len) 

def find_problem_size(locations, algorithm):
    """Finds the number of binary variables needed
    
    Parameters
    ----------
    locations : int
        Number of locations
    algorithm : Integer
        1 = Naive, 2 = ORCA aware 1, 3 = Improved ORCA aware

    Returns
    ----------
    bin_len : int
        Length of the longest bit string needed to hold the next integer in the cycle
    pb_dim : int
        Length of the PT Bit string needed to store the problem
    """

    bin_len = find_bin_length(locations)
    if algorithm == 1:
        bin_len = 0
        pb_dim = (locations-1)*(locations-1)
    elif algorithm == 2:
        pb_dim = int(bin_len * (locations - 1))  
    elif algorithm == 3:
        pb_dim = 0
        for i in range(1, locations):
            bin_len = find_bin_length(i)
            pb_dim += bin_len
    else:
        raise Exception ('ALGORITHM MUST BE 1, 2 OR 3')
    return(bin_len, pb_dim)

def convert_binary_list_to_integer(binary_list, bin_len, reverse=True):
    """Converts list of binary numbers to an integer
    
    Parameters
    ----------
    binary_list : list
        List of binary numbers
    bin_len: int
        Length of the list of binary numbers
    reverse: bool
        reverse the string

    Returns
    ----------
    sum : int
        The integer represented by the concatenated binary string
    """
    
    sum = 0
    if reverse:
        binary_list.reverse()

    for i in range(0, bin_len):
        sum += binary_list[i] * 2**i
    return(sum)

def prepare_first_list_of_locs(bit_string_list, bin_len):
    """prepares a list of integers from the ORCA bit string provided
    
    Parameters
    ----------
    bit_string_list : list
        The binary string generated by the ORCA PT-1
    bin_len:
        Length of the list

    Returns
    ----------
    output_list
        The PT1 bit string converted into a list of integers.
    """
    
    output_list = []
    length = len(bit_string_list)
    if length % bin_len != 0:
        raise ValueError('Bit string length is not a multiple of locations')
    binary_list = [[bit_string_list[i] for i in range(j,bin_len+j)] for j in range(0,length,bin_len)]
    for items in binary_list:
        integer = convert_binary_list_to_integer(items, bin_len)
        output_list.append(integer)
    return(output_list)

def check_loc_list(loc_list, locs):
    """checks that the location list is a valid cycle with no repetition of nodes.
    
    Parameters
    ----------
    loc_list : list
        A list of locations with a length one less than the number of locations in the problem
    locs : int
        The total number of locations in the problem

    Returns
    ----------
    valid : Boolean
        Whether the loc_list is a valid cycle

    """
    valid = True
    for i in range(len(loc_list)):
        if loc_list[i] > (locs - 1):
            valid = False
    for i in range(0, locs-1):
        for j in range(0, locs-1):
            if i != j:
                if loc_list[i] == loc_list[j]:
                    valid = False
    return(valid)

def augment_loc_list(loc_list, locs):
    """completes the cycle by adding the missing location to the end of the cycle.
    
    Parameters
    ----------
    loc_list : list
        A list of locations with a length one less than the number of locations in the problem
    locs : int
        The total number of locations in the problem

    Returns
    ----------
    valid : loc_list
        The original location list with the missing node list added to the end of the cycle

    """
    
    full_list = [i for i in range(0,locs)]
    for item in full_list:
        if item not in loc_list:
            add_item = item
    loc_list.append(add_item)
    return(loc_list)

def find_total_distance(int_list, locs, distance_array, debug=False):
    """finds the total distance for a valid formatted bit string representing a cycle.
    If relevant applies a distance penalty
    
    Parameters
    ----------
    int_list : list of integers
        A list representing a valid cycle
    locs: int
        The number of locations
    distance_array : array
        Numpy symmetric array with distances

    Returns
    ----------
    total_distance : float
        The total distance for the cycle represented by that bit string
    """
    total_distance = 0
    for i in range(0, locs):
        if i < locs-1:
            j = i + 1
        elif i == locs - 1:
            #complete cycle
            j = 0
        else:
            raise Exception('Unexpected values of i in loop')
        distance = find_distance(int_list[i], int_list[j], distance_array, debug)
        total_distance += distance
    return total_distance

def cost_fn_fact(locs,bin_len,distance_array,penalty=0,debug=False,algorithm=3):
    """ returns a function"""
    def cost_fn(PT_bit_string):
        """returns the value of the objective function for a PT_bit_string"""
        if algorithm == 1:
            shaped_array = convert_PT_string_to_matrix(PT_bit_string, locs)  
            penalty_sum1, penalty_sum2 = calculate_penalty_sums(shaped_array, locs)
            distance = calculate_distance(shaped_array, distance_array, locs)
            total = penalty * (penalty_sum1 + penalty_sum2) + distance
            return(total)
        elif algorithm ==2:
            first_list_of_locs = prepare_first_list_of_locs(PT_bit_string,bin_len)
            valid = check_loc_list(first_list_of_locs,locs)                   
            if not valid:
                return penalty
            else:
                full_list_of_locs = augment_loc_list(first_list_of_locs, locs)
                total_distance = find_total_distance(full_list_of_locs, locs, distance_array)
                if debug:    
                    print(f' Total distance for a valid segment is {total_distance}')
                return total_distance
        elif algorithm ==3:
            full_list_of_locs = convert_PT_bit_string_to_cycle(PT_bit_string, locs)
            total_distance = find_total_distance(full_list_of_locs, locs, distance_array)
            valid = check_loc_list(full_list_of_locs,locs)
            if not valid:
                raise Exception('Improved algorithm failed test')
            else:
                if debug:
                    print(f'PT bitstring = {PT_bit_string}, full_list_of_locs = {full_list_of_locs}, distance = {total_distance}')
                return total_distance
        else:
            raise Exception ('ALGORITHM MUST BE 1, 2 OR 3')

    return cost_fn

def convert_PT_bit_string_to_cycle(PT_bit_string,locs):
    """converts at PT_bit_string_to_a_cycle.
    
    Parameters
    ----------
    PT_bit_string : list
        A list of zeros and ones produced by the PT Series 
    locs: int
        The number of locations

    Returns
    ----------
    end_cycle_list : list
        A list of integers showing a cycle
    """
    
    PT_bit_string_copy = copy.deepcopy(PT_bit_string)
    end_cycle_list = []
    start_cycle_list = [i for i in range(locs)]
    end_cycle_list.append(start_cycle_list.pop(0)) #end point of cycle is always 0
    for i in range(locs-1, 1, -1):
        bin_len = find_bin_length(i)
        bin_string = []
        for count in range(bin_len):
            j = bin_len - 1 - count
            bin_string.append(PT_bit_string_copy.pop(j))
        position = convert_binary_list_to_integer(bin_string, bin_len, False)
        index = position % i    
        end_cycle_list.append(start_cycle_list.pop(index))
    end_cycle_list.append(start_cycle_list.pop(0))#only one entry left if i =1
    if start_cycle_list != []:
        raise Exception('Cycle returned may not be complete')
    if PT_bit_string_copy != []:
        raise Exception(f'PT_bit_string not consumed {PT_bit_string_copy} left')
    return(end_cycle_list)

def convert_PT_string_to_matrix(PT_bit_string, locs):
    """converts bit string to an array.
    square array with dimensions locs**2

    Parameters
    ----------
    PT_bit_string : list
        A list of zeros and ones produced by the PT Series 
    locs: int
        The number of locations

    Returns
    ----------
    final_array : numpy array
        A square array with dimensions locs**2.
    """
    PT_bit_string_copy = copy.deepcopy(PT_bit_string)
    shaped_array = np.array(PT_bit_string_copy).reshape(locs-1, locs-1)
    new_array = np.array([], dtype=int)
    arr_0 = np.array([0])
    arr_1 = np.array([1])
    zero_slice = np.zeros(locs-1, dtype=int)
    for i in range(locs):    
        if i == 0:
            new_slice = np.concatenate((arr_1,zero_slice))
        else:
            slice = shaped_array[i-1,0:locs-1]
            new_slice = np.concatenate((arr_0, slice))
        new_array = np.concatenate((new_array, new_slice))
    final_array = np.array(new_array).reshape(locs, locs)
    return(final_array)

def calculate_penalty_sums(shaped_array, locs):
    """returns sum for calculation of penalties for shaped array
    A non zero sum is returned in any matrix rows or columns are the same.

    Parameters
    ----------
    shaped_array: numpy array
        A square matrix where the v.i th entry is a 1 if the vth vertex is in order i in the cycle
    locs: int
        The number of locations

    Returns
    ----------
    sum1: integer
        A zero sum of each vertex appears once in a cycle
    sum2: integer
        A zero sum if there is a jth node for each cycle j
    """

    sum1 = sum2 = 0
    for v in range(locs):
        slice_sum = shaped_array[v,0:locs].sum()
        sum1 += (1-slice_sum)**2
    for j in range(locs):
        slice_sum = shaped_array[0:locs,j].sum()
        sum2 += (1-slice_sum)**2
    return(sum1, sum2)

def calculate_distance(shaped_array, distance_array, locs):
    """calculates the round trip distance

    Parameters
    ----------
    shaped_array: numpy array
        A square matrix where the v.i th entry is a 1 if the vth vertex is in order i in the cycle
    distance_array: numpy array
        A square matrix encoding the distance between vertices
    locs: int
        The number of locations

    Returns
    ----------
    dist: the total distance around a cycle
    """

    dist = 0
    for u in range(locs):
        for v in range(locs):
            accum = 0
            for j in range(locs):
                if j+1 <= locs-1:
                    accum += shaped_array[u][j]*shaped_array[v][j+1]
                else:
                    accum += shaped_array[u][j]*shaped_array[v][0]
            dist += distance_array[u][v] * accum
    return(dist)